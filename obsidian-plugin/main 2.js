/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => InvertedMirrorPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian = require("obsidian");
var DEFAULT_SETTINGS = {
  autoSave: true,
  maxLineLength: 100
};
var VIEW_TYPE_INVERTED_MIRROR = "inverted-mirror-view";
var InvertedMirrorPlugin = class extends import_obsidian.Plugin {
  async onload() {
    console.log("Inverted Mirror Editor: Loading plugin...");
    await this.loadSettings();
    this.registerView(
      VIEW_TYPE_INVERTED_MIRROR,
      (leaf) => new InvertedMirrorView(leaf, this)
    );
    this.addRibbonIcon("edit-3", "Inverted Mirror Editor", () => {
      this.openInvertedView();
    });
    this.addCommand({
      id: "open-current-note-inverted",
      name: "Open Current Note in Inverted Mirror Editor",
      checkCallback: (checking) => {
        var _a;
        const activeView = this.app.workspace.getActiveViewOfType(import_obsidian.MarkdownView);
        if (activeView) {
          if (!checking) {
            this.openInvertedView((_a = activeView.file) != null ? _a : void 0);
          }
          return true;
        }
        return false;
      }
    });
    this.addCommand({
      id: "open-inverted-mirror-editor",
      name: "Open New Inverted Mirror Editor",
      callback: () => {
        this.openInvertedView();
      }
    });
    this.addSettingTab(new InvertedMirrorSettingTab(this.app, this));
    console.log("Inverted Mirror Editor: Plugin loaded successfully");
  }
  async openInvertedView(file) {
    const { workspace } = this.app;
    let leaf = null;
    const leaves = workspace.getLeavesOfType(VIEW_TYPE_INVERTED_MIRROR);
    if (leaves.length > 0) {
      leaf = leaves[0];
    } else {
      leaf = workspace.getLeaf("split", "vertical");
      await leaf.setViewState({
        type: VIEW_TYPE_INVERTED_MIRROR,
        active: true
      });
    }
    if (leaf && leaf.view instanceof InvertedMirrorView) {
      workspace.revealLeaf(leaf);
      if (file) {
        await leaf.view.loadFile(file);
      }
    }
  }
  onunload() {
    console.log("Inverted Mirror Editor: Unloading...");
    this.app.workspace.detachLeavesOfType(VIEW_TYPE_INVERTED_MIRROR);
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
};
var InvertedMirrorView = class extends import_obsidian.ItemView {
  constructor(leaf, plugin) {
    super(leaf);
    this.currentFile = null;
    // Performance optimization
    this.displayUpdatePending = false;
    this.statsUpdatePending = false;
    this.lastStatsUpdate = 0;
    this.plugin = plugin;
    this.lines = [""];
    this.currentLineIndex = 0;
    this.maxLineLength = 0;
  }
  getViewType() {
    return VIEW_TYPE_INVERTED_MIRROR;
  }
  getDisplayText() {
    return this.currentFile ? `Inverted: ${this.currentFile.basename}` : "Inverted Mirror Editor";
  }
  getIcon() {
    return "edit-3";
  }
  async loadFile(file) {
    try {
      this.currentFile = file;
      const content = await this.app.vault.read(file);
      const fileLines = content.split("\n");
      this.lines = fileLines.reverse();
      if (this.lines.length === 0) {
        this.lines = [""];
      }
      this.currentLineIndex = 0;
      this.updateDisplay();
      this.updateStats();
      this.updateHeader();
      new import_obsidian.Notice(`Loaded: ${file.basename}`);
    } catch (error) {
      console.error("Error loading file:", error);
      new import_obsidian.Notice("Error loading file");
    }
  }
  async saveToFile() {
    if (!this.currentFile) {
      return this.saveAsNewFile();
    }
    try {
      const normalLines = this.lines.slice().reverse();
      const content = normalLines.join("\n");
      await this.app.vault.modify(this.currentFile, content);
      new import_obsidian.Notice(`Saved: ${this.currentFile.basename}`);
    } catch (error) {
      console.error("Error saving file:", error);
      new import_obsidian.Notice("Error saving file");
    }
  }
  async saveAsNewFile() {
    const normalLines = this.lines.slice().reverse();
    const content = normalLines.join("\n");
    const timestamp = new Date().toISOString().replace(/[:.]/g, "-").slice(0, -5);
    const filename = `inverted-${timestamp}.md`;
    try {
      const file = await this.app.vault.create(filename, content);
      this.currentFile = file;
      this.updateHeader();
      new import_obsidian.Notice(`Created: ${filename}`);
    } catch (error) {
      console.error("Error creating file:", error);
      new import_obsidian.Notice("Error creating file");
    }
  }
  async onOpen() {
    const container = this.containerEl.children[1];
    container.empty();
    container.addClass("inverted-mirror-container");
    const header = container.createDiv({ cls: "inverted-mirror-header" });
    this.headerEl = header.createEl("h4", { text: "Inverted Mirror Editor" });
    const toolbar = container.createDiv({ cls: "inverted-mirror-toolbar" });
    const saveBtn = toolbar.createEl("button", { text: "\u{1F4BE} Save", cls: "mod-cta" });
    saveBtn.onclick = () => this.saveToFile();
    const saveAsBtn = toolbar.createEl("button", { text: "\u{1F4C4} Save As New" });
    saveAsBtn.onclick = () => this.saveAsNewFile();
    const clearBtn = toolbar.createEl("button", { text: "\u{1F5D1}\uFE0F Clear", cls: "mod-warning" });
    clearBtn.onclick = () => this.handleClear();
    const copyBtn = toolbar.createEl("button", { text: "\u{1F4CB} Copy" });
    copyBtn.onclick = () => this.handleCopy();
    const editorWrapper = container.createDiv({ cls: "inverted-mirror-editor-wrapper" });
    editorWrapper.createDiv({ cls: "fixed-point-marker", text: "\u25B6" });
    editorWrapper.createDiv({ cls: "fixed-cursor-marker", text: "|" });
    this.editorEl = editorWrapper.createDiv({ cls: "inverted-mirror-editor" });
    this.editorEl.tabIndex = 0;
    this.statsEl = container.createDiv({ cls: "inverted-mirror-stats" });
    this.updateStats();
    this.editorEl.addEventListener("keydown", this.handleKeyDown.bind(this));
    this.editorEl.addEventListener("paste", this.handlePaste.bind(this));
    if (this.plugin.settings.autoSave) {
      this.registerInterval(
        window.setInterval(() => {
          if (this.currentFile) {
            this.saveToFile();
          }
        }, 3e4)
        // Auto-save every 30 seconds
      );
    }
    this.updateDisplay();
    this.editorEl.focus();
  }
  updateHeader() {
    if (this.headerEl) {
      const title = this.currentFile ? `Inverted: ${this.currentFile.basename}` : "Inverted Mirror Editor (New)";
      this.headerEl.setText(title);
    }
  }
  handleKeyDown(e) {
    if ((e.ctrlKey || e.metaKey) && e.key === "s") {
      e.preventDefault();
      this.saveToFile();
      return;
    }
    if ((e.ctrlKey || e.metaKey) && e.key === "c") {
      e.preventDefault();
      this.handleCopy();
      return;
    }
    if (["ArrowLeft", "ArrowRight", "ArrowUp", "ArrowDown", "Home", "End", "PageUp", "PageDown"].includes(e.key)) {
      e.preventDefault();
      return;
    }
    if (e.key === "Backspace" || e.key === "Delete") {
      e.preventDefault();
      this.handleBackspace();
      return;
    }
    if (e.key === "Enter") {
      e.preventDefault();
      this.handleEnter();
      return;
    }
    if (e.key.length === 1 && !e.ctrlKey && !e.metaKey && !e.altKey) {
      e.preventDefault();
      this.insertCharacter(e.key);
      return;
    }
  }
  insertCharacter(char) {
    this.lines[this.currentLineIndex] = char + this.lines[this.currentLineIndex];
    this.scheduleDisplayUpdate();
    this.checkLineWrap();
    this.scheduleStatsUpdate();
  }
  checkLineWrap() {
    if (!this.maxLineLength) {
      const editorWidth = this.editorEl.clientWidth;
      const availableWidth = editorWidth - 80;
      const charWidth = 10;
      this.maxLineLength = Math.floor(availableWidth / charWidth);
      this.maxLineLength = Math.max(20, Math.min(this.maxLineLength, this.plugin.settings.maxLineLength));
    }
    let lineIndex = this.currentLineIndex;
    let hasChanges = false;
    while (lineIndex < this.lines.length) {
      const line = this.lines[lineIndex];
      if (line.length > this.maxLineLength) {
        hasChanges = true;
        const keepInCurrent = line.substring(0, this.maxLineLength);
        const moveToNext = line.substring(this.maxLineLength);
        this.lines[lineIndex] = keepInCurrent;
        if (this.lines.length > lineIndex + 1) {
          this.lines[lineIndex + 1] = moveToNext + this.lines[lineIndex + 1];
        } else {
          this.lines.splice(lineIndex + 1, 0, moveToNext);
        }
        lineIndex++;
      } else {
        break;
      }
    }
    if (hasChanges) {
      this.updateDisplay();
    }
  }
  handleBackspace() {
    const currentLine = this.lines[this.currentLineIndex];
    if (currentLine.length > 0) {
      this.lines[this.currentLineIndex] = currentLine.slice(1);
    } else if (this.lines.length > 1 && this.currentLineIndex < this.lines.length - 1) {
      this.lines.splice(this.currentLineIndex, 1);
      if (this.currentLineIndex > 0) {
        this.currentLineIndex--;
      }
    }
    this.scheduleDisplayUpdate();
    this.scheduleStatsUpdate();
  }
  handleEnter() {
    this.lines.unshift("");
    this.currentLineIndex = 0;
    this.scheduleDisplayUpdate();
    this.scheduleStatsUpdate();
  }
  handlePaste(e) {
    var _a;
    e.preventDefault();
    const pastedText = (_a = e.clipboardData) == null ? void 0 : _a.getData("text/plain");
    if (pastedText) {
      const pastedLines = pastedText.split("\n");
      this.lines[this.currentLineIndex] += pastedLines[0];
      for (let i = 1; i < pastedLines.length; i++) {
        this.lines.unshift(pastedLines[i]);
        this.currentLineIndex++;
      }
      this.scheduleDisplayUpdate();
      this.scheduleStatsUpdate();
    }
  }
  scheduleDisplayUpdate() {
    if (this.displayUpdatePending)
      return;
    this.displayUpdatePending = true;
    requestAnimationFrame(() => {
      this.updateDisplay();
      this.displayUpdatePending = false;
    });
  }
  scheduleStatsUpdate() {
    const now = Date.now();
    if (now - this.lastStatsUpdate < 100) {
      if (!this.statsUpdatePending) {
        this.statsUpdatePending = true;
        setTimeout(() => {
          this.updateStats();
          this.statsUpdatePending = false;
          this.lastStatsUpdate = Date.now();
        }, 100);
      }
      return;
    }
    this.updateStats();
    this.lastStatsUpdate = now;
  }
  updateDisplay() {
    this.editorEl.empty();
    this.lines.forEach((line, index) => {
      const lineDiv = this.editorEl.createDiv({ cls: "editor-line" });
      if (index === this.currentLineIndex) {
        lineDiv.addClass("current-line");
      }
      const textContainer = lineDiv.createSpan({ cls: "editor-text" });
      textContainer.textContent = line || "\xA0";
    });
  }
  updateStats() {
    const chars = this.lines.join("").length;
    const lines = this.lines.length;
    const saved = this.currentFile ? "\u{1F4BE}" : "\u{1F4DD}";
    this.statsEl.setText(`${saved} Characters: ${chars} | Lines: ${lines}`);
  }
  handleClear() {
    const totalChars = this.lines.join("").length;
    if (totalChars === 0)
      return;
    this.lines = [""];
    this.currentLineIndex = 0;
    this.updateDisplay();
    this.updateStats();
    new import_obsidian.Notice("Content cleared");
  }
  handleCopy() {
    const normalLines = this.lines.slice().reverse();
    const content = normalLines.join("\n");
    if (content.length === 0) {
      new import_obsidian.Notice("Nothing to copy");
      return;
    }
    navigator.clipboard.writeText(content).then(() => {
      new import_obsidian.Notice("Copied to clipboard");
    });
  }
  async onClose() {
    if (this.plugin.settings.autoSave && this.currentFile) {
      await this.saveToFile();
    }
  }
};
var InvertedMirrorSettingTab = class extends import_obsidian.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h2", { text: "Inverted Mirror Editor Settings" });
    new import_obsidian.Setting(containerEl).setName("Auto-save").setDesc("Automatically save changes every 30 seconds").addToggle((toggle) => toggle.setValue(this.plugin.settings.autoSave).onChange(async (value) => {
      this.plugin.settings.autoSave = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Max Line Length").setDesc("Maximum characters per line before wrapping (20-150)").addText((text) => text.setPlaceholder("100").setValue(String(this.plugin.settings.maxLineLength)).onChange(async (value) => {
      const num = parseInt(value);
      if (!isNaN(num) && num >= 20 && num <= 150) {
        this.plugin.settings.maxLineLength = num;
        await this.plugin.saveSettings();
      }
    }));
    containerEl.createEl("h3", { text: "Usage" });
    const usage = containerEl.createEl("div", { cls: "setting-item-description" });
    usage.createEl("p", { text: "\u{1F4DD} Open current note in inverted mirror mode:" });
    usage.createEl("p", { text: 'Command Palette \u2192 "Open Current Note in Inverted Mirror Editor"' });
    usage.createEl("p", { text: "\u{1F4BE} Save: Cmd/Ctrl + S or use Save button" });
    usage.createEl("p", { text: "\u{1F4CB} Copy: Cmd/Ctrl + C or use Copy button" });
  }
};
